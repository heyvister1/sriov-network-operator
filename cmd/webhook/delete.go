package main

import (
	"context"
	"fmt"
	"os"
	"sync"
	"time"

	snolog "github.com/k8snetworkplumbingwg/sriov-network-operator/pkg/log"
	"github.com/spf13/cobra"
	"k8s.io/client-go/dynamic"

	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"sigs.k8s.io/controller-runtime/pkg/log"

	sriovnetworkv1 "github.com/k8snetworkplumbingwg/sriov-network-operator/pkg/client/clientset/versioned/typed/sriovnetwork/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/watch"
)

var (
	// Generated cluster wide resources generated by sriov-network-operator
	// These resources will be watched for deletion by runDeleteCmd
	gvrMutatingWebhookConfiguration   = schema.GroupVersionResource{Group: "admissionregistration.k8s.io", Version: "v1", Resource: "mutatingwebhookconfigurations"}
	gvrValidatingWebhookConfiguration = schema.GroupVersionResource{Group: "admissionregistration.k8s.io", Version: "v1", Resource: "validatingwebhookconfigurations"}
	gvrClusterRoles                   = schema.GroupVersionResource{Group: "rbac.authorization.k8s.io", Version: "v1", Resource: "clusterroles"}
	gvrClusterRoleBinding             = schema.GroupVersionResource{Group: "rbac.authorization.k8s.io", Version: "v1", Resource: "clusterrolebindings"}

	clusterResources = []schema.GroupVersionResource{gvrValidatingWebhookConfiguration, gvrMutatingWebhookConfiguration, gvrClusterRoles, gvrClusterRoleBinding}
)

var (
	dynamicClient *dynamic.DynamicClient
	watcherTO     int
	namespace     string
	labelSelector string
	wg            sync.WaitGroup
)

var (
	deleteCmd = &cobra.Command{
		Use:   "delete",
		Short: "Deletes provisioned sriov-operator non-namespaced objects",
		Long:  "Deletes provisioned sriov-operator non-namespaced objects e.g clusterroles/clusterrolebinding/validating/mutating webhooks",
		Run:   runDeleteCmd,
	}
)

func init() {
	rootCmd.AddCommand(deleteCmd)
	deleteCmd.Flags().StringVarP(&namespace, "namespace", "n", "", "designated SriovOperatorConfig namespace")
	deleteCmd.Flags().StringVarP(&labelSelector, "label-selector", "l", "", "sriov-network-operator provisioned webhooks specified labels")
	deleteCmd.Flags().IntVarP(&watcherTO, "watcher-timeout", "t", 10, "sriov-network-operator watch context defined timeout")
}

func DynamicClientFor(g schema.GroupVersionKind, obj *unstructured.Unstructured, namespace string) (dynamic.ResourceInterface, error) {
	return nil, nil
}

func runDeleteCmd(cmd *cobra.Command, args []string) {
	var (
		config *rest.Config
		err    error
	)
	// init logger
	snolog.InitLog()
	setupLog := log.Log.WithName("sriov-network-operator-webhook")

	setupLog.Info("Run sriov-network-operator-webhook deletion")

	// creates the in-cluster config
	kubeconfig := os.Getenv("KUBECONFIG")
	if kubeconfig != "" {
		config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)
	} else {
		config, err = rest.InClusterConfig()
	}
	if err != nil {
		setupLog.Error(err, "failed initialization k8s rest config")
	}
	// use dynamic client to iterate over 'clusterResources' (multiple objects)
	dynamicClient, err = dynamic.NewForConfig(config)
	if err != nil {
		setupLog.Error(err, "failed to create k8s dynamic client")
	}

	sriovcs, err := sriovnetworkv1.NewForConfig(config)
	if err != nil {
		setupLog.Error(err, "failed to create 'sriovnetworkv1' clientset")
	}

	def, err := sriovcs.SriovOperatorConfigs(namespace).Get(context.Background(), "default", metav1.GetOptions{})
	if err != nil {
		setupLog.Error(err, "failed to get 'default' SriovOperatorConfig")
		os.Exit(1)
	}

	def.Spec.EnableInjector = false
	def.Spec.EnableOperatorWebhook = false

	out, err := sriovcs.SriovOperatorConfigs(namespace).Update(context.Background(), def, metav1.UpdateOptions{})
	if err != nil {
		setupLog.Error(fmt.Errorf("%v. %v", err, out), "failed to update SriovOperatorConfig")
		os.Exit(1)
	}

	opts := metav1.ListOptions{
		TypeMeta:      metav1.TypeMeta{},
		LabelSelector: labelSelector,
		FieldSelector: "",
	}

	watch := func(rsrc schema.GroupVersionResource) {
		dr := dynamicClient.Resource(rsrc)
		wh, err := dr.List(context.Background(), opts)
		if err != nil {
			setupLog.Error(err, "failed to list", rsrc.Resource, "objects")
		}
		if len(wh.Items) == 0 {
			setupLog.V(0).Info("could not find", "webhooks", rsrc.Resource)
			wg.Done()
			return
		} else {
			setupLog.V(0).Info("found the following", "resource", rsrc.Resource, "items", len(wh.Items))
		}

		ctx, cancel := context.WithTimeout(context.Background(), time.Duration(watcherTO)*time.Second)
		defer cancel()
		watcher, err := dr.Watch(ctx, opts)
		if err != nil {
			setupLog.Error(err, "failed to establish sriov-operator-webhook cluster objects deletion watcher")

		}

		defer watcher.Stop()
		for {
			select {
			case event := <-watcher.ResultChan():
				if event.Type == watch.Deleted {
					wh, _ := dr.List(context.Background(), opts)
					setupLog.V(6).Info("remainin sriov-network-operator", "cluster objects:", len(wh.Items))
					if len(wh.Items) == 0 {
						setupLog.Info("watched objects have been deleted", "successfuly", rsrc.Resource)
						wg.Done()
						return
					}
				}

			case <-ctx.Done():
				setupLog.Error(err, "sriov-operator-webhook delete watch timeout for", rsrc.Resource, "occurred")
				wg.Done()
				return
			}
		}
	}

	wg.Add(len(clusterResources))
	for _, r := range clusterResources {
		go watch(r)
	}
	wg.Wait()

	os.Exit(0)
}
